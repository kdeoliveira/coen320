
#include <rtos_shared_mem.hpp>
#include "common.hpp"


/**
 * @brief Main consumer task that is responsible for outputting the value generated by the producer process
 * 
 */
class SensorDataTask : public rtos::Task<char *>{
    public:
        SensorDataTask(const char* shared_name, u_int8_t header) : m_input_buffer{shared_name}, m_header{new SensorsHeader{(SensorsHeader)header} }{
        }


        ~SensorDataTask(){

            delete m_header;
        }

        void run() override{

            

            


            if(this->m_input_buffer->buffer[*m_header].header.size > 0)
                std::cout << "\033[1;32m" << this->m_input_buffer->buffer[*m_header].header.id << ": " << this->m_input_buffer->buffer[*m_header].payload << "\033[0m" << std::endl;
        }


    private:
        rtos::SharedMem<buffer_packet> m_input_buffer;
        SensorsHeader* m_header;
};


/**
 * @brief Consumer process responsible for periodically outputting the required data on the terminal
 * 
 * @param argc 
 * @param argv file descriptors opened by the parent process
 */
int main(int argc, char *argv[])
{
    try{
        puts("Starting consumer task");

        /**
         * @brief Starts a new thread for the consumer task
         * 
         */
        rtos::Task<char *>* consumer[12];
        std::unique_ptr<MainThread> thread_consumer[12];
        
        for(u_int8_t i{0}; i < 12U ; i++){
            consumer[i] = new SensorDataTask("m_buffer_input", i);
            thread_consumer[i] = std::make_unique<MainThread>((int)i, consumer[i]);
        }

        for(u_int8_t i{0}; i < 12U ; i++){
            thread_consumer[i]->start();
        }

        /**
         * @brief Starts the scheduler algorithm which is executed on every SIGUSR1 singal 
         * 
         */
        auto *algo = new SchedulerAlgo{2, "consumer"};

        rtos::Scheduler<period_task> sched_consumer{SIGUSR1, algo, 5};

        period_task c_task[2];
        c_task[0].period = (uint8_t)1;
        c_task[0].thread_id = thread_consumer[0]->get_thread_id();

        c_task[1].period = (uint8_t)1;
        c_task[1].thread_id = thread_consumer[1]->get_thread_id();

        algo->push(c_task[0], c_task[1]);

        sched_consumer.dispatch(SIGUSR2);


        for(u_int8_t i{0}; i < 12U ; i++){
            thread_consumer[i]->join();
        }

    }
    catch(std::exception& e){
        std::cout << "ERROR: " << e.what() << std::endl;
    }
    catch(char const* x){
        puts(x);
    }


    return EXIT_SUCCESS;
}